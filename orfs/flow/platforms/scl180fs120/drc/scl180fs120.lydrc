<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SCL180 FS120 - BEOL/PDN DRC sanity (M1-M4 route, M5/TOP_M power/optional route)</description>
 <category>drc</category>
 <autorun>false</autorun>
 <show-in-menu>true</show-in-menu>
 <group-name>drc_scripts</group-name>
 <menu-path>tools_menu.drc.end</menu-path>
 <interpreter>dsl</interpreter>
 <dsl-interpreter-name>drc-dsl-xml</dsl-interpreter-name>
 <text>
# =============================================================================
# SCL180 FS120 - lightweight DRC for routing + PDN sanity
# Source of layer numbers: DRM.pdf (mapping table)
# Metal stack intent:
#   - M1..M4: routing
#   - M5 + TOP_M: power preferred, routing allowed if required
#
# Run (batch example):
#   klayout -b -r scl180fs120.lydrc -rd in_gds=chip.gds -rd report_file=drc.rpt
# =============================================================================

if $in_gds
  source($in_gds)
end

if $report_file
  report("SCL180FS120 DRC runset", $report_file)
else
  report("SCL180FS120 DRC runset", File.join(File.dirname(RBA::CellView::active.filename), "scl180fs120_drc.rpt"))
end

# -----------------------
# Enable/disable blocks
# -----------------------
BEOL     = true
OFFGRID  = true

# If you want to “ignore” signal-routing style checks on M5/TOP_M, set these false
CHECK_M5     = true
CHECK_TOP_M  = true

# KLayout runtime setup
tiles(1000.um)
tile_borders(1.um)
deep
threads(4)
verbose(true)

# =============================================================================
# Layer definitions (GDS layer/datatype)
# =============================================================================
# From DRM mapping table:
# AA     = 9
# GC     = 8
# CS     = 34
# M1     = 40
# V2     = 41
# M2     = 42
# V3     = 43
# M3     = 44
# V4     = 45
# M4     = 46
# V5     = 47
# M5     = 48
# TOP_V  = 49
# TOP_M  = 50
#
# We use wildcard datatypes to avoid missing shapes coming from pins/labels/etc.
# If you want *only* datatype 0, replace "40/0-255" with polygons(40,0), etc.

aa    = polygons("9/0-255")
gc    = polygons("8/0-255")

cs    = polygons("34/0-255")     # contact (AA/GC to M1 connection in many flows)

m1    = polygons("40/0-255")
v2    = polygons("41/0-255")
m2    = polygons("42/0-255")
v3    = polygons("43/0-255")
m3    = polygons("44/0-255")
v4    = polygons("45/0-255")
m4    = polygons("46/0-255")
v5    = polygons("47/0-255")
m5    = polygons("48/0-255")
top_v = polygons("49/0-255")
top_m = polygons("50/0-255")

# =============================================================================
# DRC checks
# =============================================================================
info("SCL180FS120 DRC start")

if BEOL
  info("BEOL checks")

  # -----------------------
  # Width / Spacing
  # Values taken from scl18fs120_tech.lef (basic min rules):
  #   M1:   W>=0.23  S>=0.23
  #   M2-5: W>=0.28  S>=0.28
  #   TOP_M:W>=0.44  S>=0.46
  # V2-5 spacing (CUT layer spacing) from tech lef:
  #   V2-5: S>=0.26
  #   TOP_V:S>=0.35
  # -----------------------

  # M1
  m1.width(0.23, euclidian).output("M1.W", "M1 min width 0.23um")
  m1.space(0.23, euclidian).output("M1.S", "M1 min spacing 0.23um")

  # M2
  m2.width(0.28, euclidian).output("M2.W", "M2 min width 0.28um")
  m2.space(0.28, euclidian).output("M2.S", "M2 min spacing 0.28um")

  # M3
  m3.width(0.28, euclidian).output("M3.W", "M3 min width 0.28um")
  m3.space(0.28, euclidian).output("M3.S", "M3 min spacing 0.28um")

  # M4
  m4.width(0.28, euclidian).output("M4.W", "M4 min width 0.28um")
  m4.space(0.28, euclidian).output("M4.S", "M4 min spacing 0.28um")

  # M5 (power preferred, but if used for routing we still want it clean)
  if CHECK_M5
    m5.width(0.28, euclidian).output("M5.W", "M5 min width 0.28um")
    m5.space(0.28, euclidian).output("M5.S", "M5 min spacing 0.28um")
  end

  # TOP_M (power only in many flows; enable/disable)
  if CHECK_TOP_M
    top_m.width(0.44, euclidian).output("TOP_M.W", "TOP_M min width 0.44um")
    top_m.space(0.46, euclidian).output("TOP_M.S", "TOP_M min spacing 0.46um")
  end

  # -----------------------
  # Via/Cut coverage checks (must be covered by both adjacent metals)
  # -----------------------
  v2.not(m1).output("V2.COV.M1", "V2 must be covered by M1")
  v2.not(m2).output("V2.COV.M2", "V2 must be covered by M2")

  v3.not(m2).output("V3.COV.M2", "V3 must be covered by M2")
  v3.not(m3).output("V3.COV.M3", "V3 must be covered by M3")

  v4.not(m3).output("V4.COV.M3", "V4 must be covered by M3")
  v4.not(m4).output("V4.COV.M4", "V4 must be covered by M4")

  v5.not(m4).output("V5.COV.M4", "V5 must be covered by M4")
  v5.not(m5).output("V5.COV.M5", "V5 must be covered by M5")

  top_v.not(m5).output("TOP_V.COV.M5", "TOP_V must be covered by M5")
  top_v.not(top_m).output("TOP_V.COV.TOP_M", "TOP_V must be covered by TOP_M")

  # -----------------------
  # Via spacing (simple min spacing)
  # -----------------------
  v2.space(0.26, euclidian).output("V2.S", "V2 min spacing 0.26um")
  v3.space(0.26, euclidian).output("V3.S", "V3 min spacing 0.26um")
  v4.space(0.26, euclidian).output("V4.S", "V4 min spacing 0.26um")
  v5.space(0.26, euclidian).output("V5.S", "V5 min spacing 0.26um")
  top_v.space(0.35, euclidian).output("TOP_V.S", "TOP_V min spacing 0.35um")

end # BEOL

if OFFGRID
  info("OFFGRID + ANGLE checks (basic)")

  # If your manufacturing grid differs, change 0.005 -> your grid (um)
  GRID = 0.005

  m1.ongrid(GRID).output("M1.OFFGRID", "M1 has off-grid vertices")
  m2.ongrid(GRID).output("M2.OFFGRID", "M2 has off-grid vertices")
  m3.ongrid(GRID).output("M3.OFFGRID", "M3 has off-grid vertices")
  m4.ongrid(GRID).output("M4.OFFGRID", "M4 has off-grid vertices")

  if CHECK_M5
    m5.ongrid(GRID).output("M5.OFFGRID", "M5 has off-grid vertices")
  end
  if CHECK_TOP_M
    top_m.ongrid(GRID).output("TOP_M.OFFGRID", "TOP_M has off-grid vertices")
  end

  # Manhattan-only for metals/cuts (good default for digital routing)
  m1.with_angle(0..90).output("M1.ANGLE", "M1 non-90deg edges found")
  m2.with_angle(0..90).output("M2.ANGLE", "M2 non-90deg edges found")
  m3.with_angle(0..90).output("M3.ANGLE", "M3 non-90deg edges found")
  m4.with_angle(0..90).output("M4.ANGLE", "M4 non-90deg edges found")
  if CHECK_M5
    m5.with_angle(0..90).output("M5.ANGLE", "M5 non-90deg edges found")
  end
  if CHECK_TOP_M
    top_m.with_angle(0..90).output("TOP_M.ANGLE", "TOP_M non-90deg edges found")
  end

  v2.with_angle(0..90).output("V2.ANGLE", "V2 non-90deg edges found")
  v3.with_angle(0..90).output("V3.ANGLE", "V3 non-90deg edges found")
  v4.with_angle(0..90).output("V4.ANGLE", "V4 non-90deg edges found")
  v5.with_angle(0..90).output("V5.ANGLE", "V5 non-90deg edges found")
  top_v.with_angle(0..90).output("TOP_V.ANGLE", "TOP_V non-90deg edges found")
end

info("SCL180FS120 DRC end")
</text>
</klayout-macro>

